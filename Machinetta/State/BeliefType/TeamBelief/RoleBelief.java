/*******************************************************************************
 * Copyright (C) 2017, Paul Scerri, Sean R Owens
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
/*
 * Role.java
 *
 * Created on 15 August 2002, 20:59
 */

package Machinetta.State.BeliefType.TeamBelief;

import Machinetta.State.*;
import Machinetta.State.BeliefType.*;
import Machinetta.State.BeliefType.TeamBelief.Constraints.DirectedInformationRequirement;
import Machinetta.State.BeliefType.TeamBelief.Constraints.GeneratedInformationRequirement;
import java.util.ArrayList;

import java.util.Hashtable;
import java.util.Vector;

/**
 * Currently the specification of a role is a simple string
 * this is *not* intended to stay, just for initial testing
 *
 * @author  scerri
 */
public abstract class RoleBelief extends Belief {
    
    /** Name of the role, may not remain */
    public String roleName = null;
    
    /** The RAP responsible for completing this role. */
    public RAPBelief responsibleRAP = null;
    
    /** The team plan within which this role operats */
    public TeamPlanBelief plan = null;
    
    /** The state of this role belief (whether it's still relevant or not) */
    public boolean activation = true;
    
    /** Whether or not permission is required to execute the role */
    public boolean authorized = true;
    
    /** True iff the role has been completed. <br>
     *
     * if true then activation will be false.
     */
    public boolean completed = false;
    
    /** If true, the RAP should not start executing the role */
    public boolean constrainedWait = true;
    
    /** These indicate information sharing requirements specific to this role.
     *
     * It will be null, if this role entails no specific information sharing
     * responsibilities.
     *
     * Commenting this back in - not sure why it was commented out, but causes a compilation error
     * in RoleAgent. Paul 1/21/06
     */
    public Vector<DirectedInformationRequirement> infoSharing = null;
    
    /** These indicate information that must be available before the role
     * should be instantiated.  These are different from the parameters
     * of the role in that (I expect) they are generated by other roles in
     * the plan.  It may be possible to merge with params, but not sure.
     *
     */
    public Vector<GeneratedInformationRequirement> generatedInfo = null;
    
    /** Time at which role should start being executed. <br>
     * Not always relevant <br>
     *
     * -1 if not scheduled. <br>
     *
     * > 0 for testing.
     */
    public int scheduled = -1;
    
    public boolean scheduleChangeRequest = false;
    public boolean rescheduled = false;
    
    /** Whether or not RAP has been notified that it has this role (if it has) */
    private boolean RAPNotified = false;
    
    private ArrayList<ProxyID> teammates = new ArrayList<ProxyID>();
    
    /** Access to state */
    protected transient ProxyState state = new ProxyState();
    
    /** Creates a new instance of Role */
    public RoleBelief(BeliefID id, String roleName) {
        super(id);
        this.roleName = roleName;
    }
    
    /*
    public RoleBelief(BeliefID id, String roleName, Hashtable params) {
        this(id,roleName);
    }
     */
    
    /** No-arg constructor needed for BeliefsXML */
    public RoleBelief() {}
    
    /**
     * @return String with roleName
     */
    public String getRoleName() { return roleName; }
    
    /** String with role name and assignment */
    //    public String toString() { return "Role : " + roleName + " id "+getID()+" assigned to " + responsibleRAP; }
    public String toString() { return "Role : "; }
    
    /** Returns the RAPBelief object for the RAP that will fight this fire */
    public RAPBelief getResponsible() { return responsibleRAP; }
    
    /** Assign an entity to this role */
    public void setResponsible(RAPBelief responsible) {
        if (responsibleRAP != responsible) {
            Machinetta.Debugger.debug(0, "Setting responsible for " + this + " to " + responsible +
                    (responsibleRAP != null ? " replacing " + responsibleRAP : ""));
            
            responsibleRAP = responsible;
            if (responsible != null) responsible.addRole(this);
            
        }
    }
    
    /** return any parameters associated with this role */
    public Object getParams() {
        Machinetta.Debugger.debug(0, "Unimplemented getParams() in base class called");
        return null;
    }
    
    /** Associate a team plan with this particular role */
    public void setPlan(TeamPlanBelief plan) { this.plan = plan; }
    
    /** Access the plan associated with this role */
    public TeamPlanBelief getPlan() { return plan; }
    
    /** Returns the state of this role */
    public boolean isActive() { return activation; }
    
    /** Deactivates the role (roles start out active by default) */
    public void deactivate() {
        activation = false;
        Machinetta.Debugger.debug(0, "Deactivating role: " + getID());
    }
    
    /** Reactivates the role */
    public void reactivate() {
        activation = true;
        Machinetta.Debugger.debug(0, "Reactivating role : " + getID());
    }
    
    /** Indicate that this role has been completed */
    public void setComplete() {
        Machinetta.Debugger.debug(0, "Setting role to complete: " + this);
        completed = true;
        deactivate();
    }
    
    /** Check whether this role has been completed */
    public boolean isComplete() { return completed; }
    
    /** Set whether or not RAP has been notified that it has this role */
    public void setRAPNotified(boolean val) { RAPNotified = val; }
    
    /** Check whether or not RAP has been notified that it has this role  */
    public boolean RAPNotified() { return RAPNotified; }
    
    /** Returns true if the RAP should wait before executing the role */
    public boolean waitForConstrained() { return constrainedWait; }
    
    /** Release responsibility for this role */
    public void release() { setResponsible(null); }
    
    /** Two roles are equal if their ids are the same */
    public boolean equals(Object obj) {
        if (obj == null || obj.getClass() != getClass()) return false;
        RoleBelief r = (RoleBelief)obj;
        
        return r.getID().equals(getID());
    }
    
    /*********************************************
     * Abstract methods
     ********************************************/
    /** Fills in instance-specific values of this belief by lookup in the provided table
     */
    public abstract RoleBelief instantiate(Hashtable params);
    
    /*********************************************
     * End abstract methods
     ********************************************/
    
    public Vector<DirectedInformationRequirement> getInfoSharing() {
        return infoSharing;
    }
    
    public void setInfoSharing(Vector<DirectedInformationRequirement> infoSharing) {
        this.infoSharing = infoSharing;
    }

    public ArrayList<ProxyID> getTeammates() {
        return teammates;
    }
    
    public void addTeammate(ProxyID id) {
        teammates.add(id);
    }
    
    public void removeTeammate(ProxyID id) {
        teammates.remove(id);
    }
}
