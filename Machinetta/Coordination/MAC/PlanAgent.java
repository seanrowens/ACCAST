/*******************************************************************************
 * Copyright (C) 2017, Paul Scerri, Sean R Owens
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
/*
 * PlanAgent.java
 *
 * Created on November 6, 2003, 11:58 AM
 */

package Machinetta.Coordination.MAC;

import Machinetta.Coordination.MACoordination;
import Machinetta.State.BeliefType.TeamBelief.*;
import Machinetta.State.BeliefType.TeamBelief.Constraints.DirectedInformationRequirement;
import Machinetta.State.BeliefType.TeamBelief.Constraints.GeneratedInformationRequirement;
import Machinetta.State.BeliefType.TeamBelief.Constraints.RoleConstraint;
import Machinetta.State.BeliefID;
import Machinetta.State.BeliefType.Belief;
import Machinetta.State.BeliefType.ProxyID;

import java.util.*;

/**
 *
 * @author  pscerri
 */
public class PlanAgent extends Agent {
    
    /** Big temporary hack for Lockheed
     *
     * @fix schedule time is currently a constant ...
     */
    private int scheduleTime = 0;
    
    private Machinetta.State.BeliefType.TeamBelief.TeamPlanBelief plan;
    
    /**
     * This is the number the PlanAgent uses to resolve conflicts
     * when there are duplicate plans.  Be careful if changing it,
     * since race conditions can occur.
     */
    public double conflictNo = (new java.util.Random()).nextDouble();
    
    /** This is the list of ProxyIDs where there are PlanAgents that conflict
     * with this planAgent's plan. <br>
     *
     * Notice: currently does not get included in belief.
     */
    private LinkedList<Integer> inConflict = new LinkedList<Integer>();
    
    /** True of this plan is terminated (for whatever reason) <br>
     *
     */
    public boolean terminated = false;
    
    /** Agents currently performing roles as part of this plan. <br>
     *
     * Beware, currently does not move with agent ...
     *
     * @todo Performers needs to use rolePerforming
     */
    // private Hashtable<ProxyID, BeliefID> rolePerforming = new Hashtable<ProxyID, BeliefID>();
    private Hashtable<BeliefID, ProxyID>performers = new Hashtable<BeliefID,ProxyID>();
    
    private Util.ReversibleHash<ProxyID, BeliefID> rolePerforming = new Util.ReversibleHash<ProxyID, BeliefID>();
    
    private Hashtable<ProxyID, Integer> scheduled = new Hashtable<ProxyID,Integer>();
    
    /** This is the list of ProxyIDs for which we have an outstanding change of schedule */
    private java.util.HashMap<ProxyID,Object> outstandingScheduleRequests = new java.util.HashMap<ProxyID,Object>();
    
    /** Roles that have been completed. <br>
     *
     * Beware, currently does not move with agent ...
     */
    private Vector<BeliefID> completedRoles = new Vector<BeliefID>();
    
    /** Beware, currently does not move with agent ...
     */
    private LinkedList<JIAgent> waitingForStart = new LinkedList<JIAgent>(), started = new java.util.LinkedList<JIAgent>();
    
    /**
     * This is the list of roles that are not instantiated because they are awaiting information that
     * should be generated by another part of the plan.
     *
     *  Beware, currently does not move with agent ...
     */
    private LinkedList<RoleBelief> waitingForGeneratedInfo = new LinkedList<RoleBelief>();
    
    /** Beware, currently does not move with agent ...
     */
    private Hashtable<BeliefID,RoleBelief> authorityRoles = new Hashtable<BeliefID,RoleBelief>();
    
    /** Creates a new instance of PlanAgent */
    public PlanAgent(Machinetta.State.BeliefType.TeamBelief.TeamPlanBelief tpb) {
        
        Machinetta.Debugger.debug( 3,"Plan Agent is created for " + tpb + " with params " + tpb.params);
        
        uniqueID = Math.abs((new java.util.Random()).nextInt());
        
        if (Machinetta.Configuration.PLAN_INSTANTIATION_POLICY.equalsIgnoreCase("LOCAL")) {
            localInstantiate(tpb);
        } else if (Machinetta.Configuration.PLAN_INSTANTIATION_POLICY.equalsIgnoreCase("ALWAYS")) {
            instantiate(tpb);
        } else if (Machinetta.Configuration.PLAN_INSTANTIATION_POLICY.equalsIgnoreCase("PROBABILISTIC")) {
            probInstantiate(tpb);
        } else {
            Machinetta.Debugger.debug( 4,"Unknown plan instantiation policy : " + Machinetta.Configuration.PLAN_INSTANTIATION_POLICY + " using Local");
            localInstantiate(tpb);
        }
    }
    
    /** Creates a plan agent from an incoming belief */
    public PlanAgent(Machinetta.State.BeliefType.MAC.PlanAgentBelief pa) {
        super(pa);
        plan = pa.plan;
        conflictNo = pa.conflictNo;
        terminated = pa.terminated;
        
        if (!MACoordination.agentExists(getDefiningBeliefs())) {
            MACoordination.addAgent(this);
            state.addBelief(plan);
            state.notifyListeners();
        }
    }
    
    public Machinetta.State.BeliefType.TeamBelief.TeamPlanBelief getPlan() { return plan; }
    
    /** Instantiates iff one or more condition is local
     *
     */
    protected void localInstantiate(Machinetta.State.BeliefType.TeamBelief.TeamPlanBelief tpb) {
        try {
            java.util.Hashtable matches = tpb.params;
            // The following requires that a beliefs leading to the instantiation of the plan
            // be locally sensed by the agent (unless there are no parameters
	    //
	    // @TODO: TeamPlanTemplate always adds both the
	    // preconditions and postconditions vectors to the params
	    // HashTable, so if either of those is non NULL, you need
	    // to have a locallySensed belief in the params as well or
	    // the plan won't instantiate.
            boolean oneLocal = (matches.size() == 0);

            // Will only instantiate the plan if at least one condition is sensed locally.
            for (java.util.Enumeration bels = matches.elements(); !oneLocal && bels.hasMoreElements(); ) {
                try {
                    Object o = bels.nextElement();
                    if (o instanceof Machinetta.State.BeliefID) {
                        Machinetta.State.BeliefType.Belief bel = state.getBelief((Machinetta.State.BeliefID)o);
                        if (bel != null) {
                            Machinetta.Debugger.debug( 0,"Checking: " + bel.getID() + " " + bel.locallySensed());
                            oneLocal = bel.locallySensed();
                        } else {
                            Machinetta.Debugger.debug( 4,"Local instantiate found null belief for id: " + o);
                        }
                    }
                } catch (ClassCastException e) {
                    Machinetta.Debugger.debug( 5,"Problem: " + e);
                }
            }
            
            if (oneLocal) {
                Machinetta.Debugger.debug( 1,"At least one belief is local, instantiating: " + tpb);
                instantiate(tpb);
            } else {
                Machinetta.Debugger.debug( 1,tpb + " disappearing because information not all local");
                // MACoordination.removeAgent(this);
                // This agent just disappears ....
                // Add the plan to the state anyway, so we don't try remaking it
                state.addBelief(tpb);
            }
        } catch (NullPointerException e) {
            Machinetta.Debugger.debug( 4,"Exception caught: " + e);
            e.printStackTrace();
        }
    }
    
    /** After some random amount of time, creates the plan if not detected already
     */
    protected void probInstantiate(final Machinetta.State.BeliefType.TeamBelief.TeamPlanBelief tpb) {
        (new Thread() {
            public void run() {
                // Add the plan to the state anyway, so we don't try remaking it
                state.addBelief(tpb);
                Machinetta.Debugger.debug( 0,"Probabilistic instantiation for " + tpb.getID() + ", waiting ... ");
                try {
                    sleep(1000 * (new java.util.Random()).nextInt(Machinetta.Configuration.PROBABILISTIC_INSTANTIATE_TIME));
                } catch (InterruptedException e) {}
                
                //if (state.getBelief(tpb.getID()) == null) {
                if (MACoordination.getConflicting(new AssociateInformAgent(tpb)) == null) {
                    Machinetta.Debugger.debug( 1,"Doing Probabilistic instantiation of : " + tpb);
                    instantiate(tpb);
                } else {
                    Machinetta.Debugger.debug( 1,"Probabilistic instantiation not required for : " + tpb);
                }
            }
        }).start();
    }
    
    /** Creates the PlanAgent, puts it in the state and immediately moves it */
    private void instantiate(Machinetta.State.BeliefType.TeamBelief.TeamPlanBelief tpb) {
        plan = tpb;
        
        // For now stick it straight into state
        state.addBelief(tpb);
        
        MACoordination.addAgent(this);
        Machinetta.Debugger.debug( 2,"Instantiated plan : " + this + " with id: " + uniqueID);
        instantiateRoles();
        
        if (Machinetta.Configuration.USE_ASSOCIATES_NETWORK) {
            informAssociates(tpb);
        }
        state.notifyListeners();
        
        // If using meta reasoning about plan completion,
        // set timer to create meta agent if not completed.
        if (plan.maximumReasonableCompletionTime > 0) {
            if (Machinetta.Configuration.PLAN_COMPLETION_META_REASONING) {
                // To give thread access
                final PlanAgent pa = this;
                
                (new Thread() {
                    public void run() {
                        Machinetta.Debugger.debug( 2,"Started completion timer thread");
                        try {
                            sleep(plan.maximumReasonableCompletionTime * 1000);
                        } catch (InterruptedException e) {}
                        // See if the plan is still around, if so create an agent to work it out
                        if (plan.isActive()) {
                            Machinetta.Debugger.debug( 2,"Initiating meta reasoning for plan completion");
                            MetaReasoningAgent agent = new MetaReasoningAgent(pa);
                            // MACoordination.addAgent(agent);
                            agent.executeStrategy();
                        }
                    }
                }).start();
            }
        }
    }
    
    /** Instantiate any required roles
     * Done as a seperate function so that subclasses can override
     */
    protected void instantiateRoles() {
        java.util.Vector v = plan.getAllRoles();
        Vector<RoleBelief> goList = new Vector<RoleBelief>();
        for (java.util.Enumeration e = v.elements(); e.hasMoreElements(); ) {
            RoleBelief role = (RoleBelief)e.nextElement();
            role.plan = plan;
            Machinetta.Debugger.debug( 1,"Instantiating role agent for : " + role);
            // check if role could proceed without checking in with PlanAgent
            role.constrainedWait = !checkProceed(role.getID());
            Machinetta.Debugger.debug( 2,"Role " + role + (role.constrainedWait ? " is" : " isn't") + " wait constrained at init");
            
            if (role.generatedInfo == null) {
                // RoleAgent ra = new RoleAgent(role, uniqueID);
                goList.add(role);
            } else {
                synchronized(waitingForGeneratedInfo) {
                    waitingForGeneratedInfo.add(role);
                }
                Machinetta.Debugger.debug( 1,"Not starting role " + role + ", require generated info .... pending = " + waitingForGeneratedInfo.size());
            }
            
        }
        
        for (RoleBelief role: goList) {
            RoleAgent ra = new RoleAgent(role, uniqueID);
        }
    }
    
    /**
     * An associateInformAgent arrives, informing that this plan is in
     * conflict with some other plan.
     */
    public void informConflict(AssociateInformAgent informer) {
        Machinetta.Debugger.debug( 1,"Plan agent informed of conflict by : " + informer);
        
        boolean found = false;
        for (java.util.ListIterator li = inConflict.listIterator(); !found && li.hasNext(); ) {
            Integer pid = (Integer)li.next();
            if (pid.intValue() == informer.uniqueIDofConflicted) {
                Machinetta.Debugger.debug( 0,"Already knew about conflict with " + informer.uniqueIDofConflicted  + ", id: " + uniqueID);
                found = true;
            }
        }
        if (!found) {
            Machinetta.Debugger.debug( 2,"Newly detected conflict with " + informer.uniqueIDofConflicted + " re. " + plan.getID()  + ", id: " + uniqueID);
            inConflict.add(informer.uniqueIDofConflicted);
            ConflictResolutionAgent ca = new ConflictResolutionAgent(plan, conflictNo, informer.uniqueIDofConflicted);
            ca.uniqueID = uniqueID;
            MACoordination.addAgent(ca);
            if (informer.conflictDetected.equals(state.getSelf().getProxyID())) {
                ca.act();
            } else {
                MACoordination.moveAgent(ca, informer.conflictDetected);
            }
        }
        
    }
    
    /** A conflict resolution agent arrives, to determine the
     * result of some conflict. <br>
     *
     * We are using one shot resolution, a number is sent, lowest
     * number keeps the plan.
     */
    public synchronized void resolveConflict(ConflictResolutionAgent ca) {
        if (terminated) return;
        if (ca.getConflictNo() < conflictNo) {
            Machinetta.Debugger.debug( 2,this + " being told to terminate due to conflict!");
            terminate();
        } else {
            Machinetta.Debugger.debug( 1,this + " continues after conflict resolution");
        }
    }
    
    /** Lets the PlanAgent know that some role has been filled  <br>
     *
     * Need to work out whether the agent needs permission to begin.
     */
    public void roleAllocated(JIAgent jia) {
        Machinetta.Debugger.debug( 1,"PlanAgent informed role allocated: " + jia);
        // @fix Notice that this (i.e., scheduling) in only here because Scheduling changes are using JIS_ROLE_ALLOCATED
        // eventually that should change (see fix in RoleAgent)
        // @todo I wonder whether there is a potential race condition here with checkProceed?
        if (outstandingScheduleRequests.containsKey(jia.getInformer())) {
            outstandingScheduleRequests.remove(jia.getInformer());
            Machinetta.Debugger.debug( 2,"Removed outstanding schedule request");
        }
        
        if (terminated) {
            Machinetta.Debugger.debug( 2,"Need to inform RA that plan is terminated: " + jia);
            Machinetta.State.BeliefType.ProxyID informer = jia.getInformer();
            jia.setState(JIAgent.JI_STATE.PLAN_TERMINATED);
            jia.setInformer(state.getSelf().getProxyID());
            MACoordination.moveAgent(jia, informer);
            // Think about leaving a clone here, but probably not required.
        } else {
            // Update local state
            RoleBelief role = (RoleBelief)state.getBelief(jia.getRoleID());
            if (role == null) {
                Machinetta.Debugger.debug( 4,"Informed of unknown role : " + jia.getRoleID());
                state.printState();
            } else {
                role.setResponsible(state.getRAPBelief(jia.getInformer()));
                state.addBelief(role);
                
                // Then see what to do with it
                Machinetta.State.BeliefType.ProxyID informer = jia.getInformer();
                rolePerforming.put(jia.getInformer(), jia.getRoleID());
                performers.put(jia.getRoleID(), jia.getInformer());
                
                // Hack for scheduling.  @fix
                int time = jia.getCapability();
                if (time > scheduleTime) scheduleTime = time;
                scheduled.put(jia.getInformer(), new Integer(time));
                Machinetta.Debugger.debug( 1,"Updated schedule for " + jia.getInformer() + " to " + time);
                // Notice that if this time is not scheduleTime then scheduleOK is sending message
                
                MACoordination.addAgent(jia);
                waitingForStart.add(jia);
                
                // Check whether this allocation has any impact on the directed information requirements.
                
                // Check whether this rolePerformer requires information from someone else
                for (RoleBelief otherRole: plan.roles) {
                    if (!otherRole.equals(role) && otherRole.infoSharing != null) {
                        for (DirectedInformationRequirement dir: otherRole.infoSharing) {
                            if (dir.performer != null && dir.performer.equals(role.getID())) {
                                Machinetta.Debugger.debug( 0,"Information receiver (" + jia.getInformer() + ") for " + dir + " now allocated");
                                if (performers.get(otherRole.getID()) != null) {
                                    Machinetta.Debugger.debug( 1,"Information receiver for " + performers.get(otherRole.getID()) + " is " + jia.getInformer() + " : " + dir);
                                    JIAgent jiinform = new JIAgent(plan.getID(), otherRole.getID(), JIAgent.JI_STATE.DIR_UPDATE);
                                    jiinform.setDIRRole(role.getID());
                                    jiinform.setDIRPerformer(jia.getInformer());
                                    jiinform.uniqueID = uniqueID;
                                    MACoordination.moveAgent(jiinform, performers.get(otherRole.getID()));
                                } else {
                                    Machinetta.Debugger.debug( 0,"Information reciever for " + role + " does not yet have source for its info");
                                }
                            }
                        }
                    }
                }
                
                // Check whether someone else needs information from this rolePerformer
                if (role.infoSharing != null) {
                    for (DirectedInformationRequirement dir: role.infoSharing) {
                        if (dir.performer != null) {
                            Machinetta.Debugger.debug( 0,"Newly allocated role (" + role + ") is an Information provider: " + dir.performer);
                            if (performers.get(dir.performer) != null) {
                                Machinetta.Debugger.debug( 1,"Information provider " + jia.getInformer() + " to send " + performers.get(dir.performer) + " : " + dir);
                                JIAgent jiinform = new JIAgent(plan.getID(), role.getID(), JIAgent.JI_STATE.DIR_UPDATE);
                                jiinform.setDIRRole(dir.performer);
                                jiinform.setDIRPerformer(performers.get(dir.performer));
                                jiinform.uniqueID = uniqueID;
                                MACoordination.moveAgent(jiinform, jia.getInformer());
                            } else {
                                Machinetta.Debugger.debug( 0,"Information provider " + jia.getInformer() + " target not yet allocated for " + dir);
                            }
                        }
                    }
                }
                
                // Inform team mates that someone has been added
                for (RoleBelief otherRole: plan.roles) {
                    if (!otherRole.equals(role) && performers.get(otherRole.getID()) != null) {
                        
                        //Machinetta.Debugger.debug(1, "TEAMMATES: " + otherRole.getID() + ":" + performers.get(otherRole.getID()) + " and " +
                        //        role.getID() + ":" + performers.get(role.getID()));
                        
                        // Tell existing team about new guy
                        JIAgent jiinform = new JIAgent(plan.getID(), otherRole.getID(), JIAgent.JI_STATE.TEAMMATE_ADD);
                        jiinform.setTeammate(performers.get(role.getID()));
                        jiinform.uniqueID = uniqueID;
                        MACoordination.moveAgent(jiinform, performers.get(otherRole.getID()));
                        
                        // Tell new guy about existing
                        JIAgent jiinformS = new JIAgent(plan.getID(), role.getID(), JIAgent.JI_STATE.TEAMMATE_ADD);
                        jiinformS.setTeammate(performers.get(otherRole.getID()));
                        jiinformS.uniqueID = uniqueID;
                        MACoordination.moveAgent(jiinformS, performers.get(role.getID()));
                    }
                }
                
                // Given the current set of allocated roles, allow them to start or not
                allowStart();
            }
        }
        
    }
    
    /** Lets the PlanAgent know that some previously filled role is now empty  <br>
     *
     * Need to work out whether whole plan should be stopped.
     *
     * @fix The first if statement makes no sense!!
     */
    public void roleDeallocated(JIAgent jia) {
        Machinetta.Debugger.debug( 2,"PlanAgent informed role deallocated: " + jia);
        if (rolePerforming.removeKey(jia.getInformer()) != null) {
            if (rolePerforming.get(jia.getInformer()) == jia.getRoleID()) {
                rolePerforming.removeKey(jia.getInformer());
            } else {
                Machinetta.Debugger.debug( 0,"Would have removed a deallocated role " + jia);
            }
        } else {
            Machinetta.Debugger.debug( 3,"Potential problem, attempt to remove role performer that was not known: " + jia.getInformer());
        }
        /*
        if (rolePerforming.remove(jia.getInformer()) == null) {
            Machinetta.Debugger.debug( 3,"Potential problem, attempt to remove role performer that was not known: " + jia.getInformer());
        }
         */
        RoleBelief role = (RoleBelief)state.getBelief(jia.getRoleID());
        role.setResponsible(null);
        state.addBelief(role);
        
        // At least one of the following does not actually work in any particular case
        boolean found = waitingForStart.remove(jia);
        found = found || started.remove(jia);
        if (!found) Machinetta.Debugger.debug( 3,"Could not find JIAgent to remove? " + jia);
        
        // Suspend any other role agents that were constrained by the execution of this role.
        for (int i = 0; i < started.size(); i++ ) {
            
            JIAgent oldjia = (JIAgent)started.get(i);
            if (!checkProceed(oldjia.getRoleID())) {
                Machinetta.Debugger.debug( 2,oldjia.getRoleID() + " needs to be suspended");
                Machinetta.State.BeliefType.ProxyID informer = oldjia.getInformer();
                // Tell the proxy to suspend the role
                oldjia.setState(JIAgent.JI_STATE.ROLE_SUSPEND);
                if (informer.equals(state.getSelf().getProxyID())) {
                    Machinetta.Debugger.debug( 2,"Telling self to suspend role " + oldjia.getRoleID());
                    oldjia.act();
                    waitingForStart.add(oldjia);
                } else {
                    // Keep a clone for later use, but don't add until other has left
                    JIAgent clone = (JIAgent)oldjia.clone();
                    // Change the "return to sender address" before sending
                    oldjia.setInformer(state.getSelf().getProxyID());
                    Machinetta.Debugger.debug( 2,"Telling " + informer + " to suspend role " + oldjia.getRoleID());
                    //MACoordination.addAgent(oldjia);
                    MACoordination.moveAgent(oldjia, informer);
                    // Now can add clone
                    MACoordination.addAgent(clone);
                    waitingForStart.add(clone);
                }
                started.remove(oldjia);
                i--;
            }
        }
        
        // @todo there are probably some DirectedInformation issues to clear up.
        
        if (!terminated)
            allowStart();
        
        // Inform team mates that someone has been removed (do this before updating lists)
        for (RoleBelief otherRole: plan.roles) {
            if (otherRole != role && performers.get(otherRole.getID()) != null) {
                JIAgent jiinform = new JIAgent(plan.getID(), otherRole.getID(), JIAgent.JI_STATE.TEAMMATE_REMOVE);
                jiinform.setTeammate(performers.get(role.getID()));
                jiinform.uniqueID = uniqueID;
                MACoordination.moveAgent(jiinform, performers.get(otherRole.getID()));
            }
        }
        
        // Update our lists
        rolePerforming.removeKey(jia.getInformer());
        performers.remove(jia.getRoleID());
    }
    
    /** Inform the plan agent that some role has been completed. */
    public void roleComplete(JIAgent jia) {
        completedRoles.add(jia.getRoleID());
        
        RoleBelief role = (RoleBelief)state.getBelief(jia.getRoleID());
        role.completed = true;
        state.addBelief(role);
        state.notifyListeners();
        
        // Possibly should check whether the plan should now be terminated?

	// @TODO: Sat Feb 21 20:29:22 EST 2009 - SRO
	// Trying to add plan termination when all roles are complete.  
	// Not sure yet if this works.
        java.util.Vector v = plan.getAllRoles();
	boolean allCompleted = true;
        for (java.util.Enumeration e = v.elements(); e.hasMoreElements(); ) {
            RoleBelief r = (RoleBelief)e.nextElement();
	    if(r.completed != true){
		allCompleted = false;
		break;
	    }
	}
	if(allCompleted) {
	    Machinetta.Debugger.debug(1,"SEAN: All Roles seem to be completed, terminating plan "+plan.getName());
	    terminate();
	}

        // Start any agents that can now be started.
        if (!terminated)
            allowStart();
    }
    
    /** Start any agents that can now be started */
    private synchronized void allowStart() {
        // Check who can now proceed
        for (int i = 0; i < waitingForStart.size(); i++) {
            JIAgent oldjia = (JIAgent)waitingForStart.get(i);
            if (checkProceed(oldjia.getRoleID())) {
                
                Machinetta.Debugger.debug( 0,"Checking start on : " + oldjia.getRoleID());
                // Check whether authority is OK
                RoleBelief role = (RoleBelief)state.getBelief(oldjia.getRoleID());
                if (role.authorized == false) {
                    Machinetta.Debugger.debug( 0,"Not authorized: " + role);
                    Machinetta.State.BeliefType.TeamBelief.DecisionMakingRole authorityRole = null;
                    authorityRole = (DecisionMakingRole)authorityRoles.get(oldjia.getRoleID());
                    if (authorityRole == null) {
                        Machinetta.State.BeliefNameID id = new Machinetta.State.BeliefNameID("Authority:" + oldjia.getRoleID());
                        Vector<String> decisionOptions = new Vector<String>();
                        decisionOptions.addElement("Authorize");
                        decisionOptions.addElement("Do Not Authorize");
                        Hashtable<String,Object> info = new Hashtable<String,Object>();
                        info.put("Role", role);
                        info.put("Assigned", role.getResponsible().getProxyID());
                        // @fix Hack for Lockheed
                        info.put("Scheduled", new Integer(scheduleTime));
                        authorityRole = new DecisionMakingRole(id, decisionOptions, info);
                        authorityRole.constrainedWait = false;
                        authorityRoles.put(oldjia.getRoleID(), authorityRole);
                        RoleAllocationBelief ra = new RoleAllocationBelief(authorityRole);
                        state.addBelief(authorityRole);
                        state.addBelief(ra);
                        state.notifyListeners();
                        Machinetta.Debugger.debug( 0,"Added DMR : " + authorityRole);
                    } else {
                        Machinetta.Debugger.debug( 0,"Existing authority role for: " + oldjia.getRoleID());
                    }
                    
                } else {
                    Machinetta.State.BeliefType.TeamBelief.DecisionMakingRole authorityRole = null;
                    authorityRole = (DecisionMakingRole)authorityRoles.get(oldjia.getRoleID());
                    if (authorityRole != null) {
                        // Send a JIAgent for authority
                        oldjia.setState(JIAgent.JI_STATE.AUTHORIZATION_GRANTED);
                        Machinetta.Debugger.debug( 2,oldjia.getInformer() + " given authority for " + oldjia.getRoleID());
                        oldjia = clonedSend(oldjia);
                    }
                    // Tell the relevant proxy that it can go ahead with the role
                    // Tell the proxy to get the role started
                    oldjia.setState(JIAgent.JI_STATE.ROLE_START);
                    // @fix Hack for Lockheed, fix!
                    oldjia.setCapability(scheduleTime);
                    Machinetta.Debugger.debug( 2,oldjia.getInformer() + " can start on " + oldjia.getRoleID());
                    waitingForStart.remove(oldjia);
                    clonedSend(oldjia);
                    
                    // Some JIA has been removed, decrement the counter to make loop work correctly
                    i--;
                }
            } else {
                Machinetta.Debugger.debug( 3,"Not sending because not can start");
            }
        }
    }
    
    
    /**
     * Sends a JIA, keeps a clone.
     * Assumes that state has been set.
     *
     * Returns clone for subsequent sends (but clone already posted to MACoordination
     */
    private JIAgent clonedSend(JIAgent oldjia) {
        Machinetta.State.BeliefType.ProxyID informer = null;
        JIAgent clone = null;
        informer = oldjia.getInformer();
        if (informer.equals(state.getSelf().getProxyID())) {
            oldjia.act();
            started.add(oldjia);
        } else {
            // Keep a clone for later use, but don't add until other has left
            clone = (JIAgent)oldjia.clone();
            // Change the "return to sender address" before sending
            oldjia.setInformer(state.getSelf().getProxyID());
            MACoordination.moveAgent(oldjia, informer);
            // Now can add clone
            MACoordination.addAgent(clone);
            started.add(clone);
        }
        return clone;
    }
    
    /** Check if constraints allow agent to start  */
    private boolean checkProceed(Machinetta.State.BeliefID roleID) {
        boolean canProceed = true;
        
        if (plan.roleConstraints != null) {
            Machinetta.Debugger.debug( 0,"Checking start constraints on : " + roleID);
            Machinetta.Debugger.debug( 0,"Constraints are : " + plan.roleConstraints);
            for (int i = 0; canProceed && i < plan.roleConstraints.size(); i++) {
                RoleConstraint c = (RoleConstraint)plan.roleConstraints.elementAt(i);
                Machinetta.Debugger.debug( 0,"Constraint: " + c);
                canProceed = c.canStart(roleID, rolePerforming.values(), completedRoles);
            }
        } else {
            Machinetta.Debugger.debug( 0,"No constraints on plan: " + plan);
        }
        
        // Need to do the schedule check last
        if (canProceed && plan.schedulable) {
            canProceed = scheduleOK();
            if (!canProceed) {
                Machinetta.Debugger.debug( 3,"Role " + roleID + " not allowed to proceed due to scheduling");
            }
        }
        
        return canProceed;
    }
    
    /**
     * @todo Will eventually need more flexible, but for now.....
     */
    int lastRequestedTime = -100;
    private boolean scheduleOK() {
        
        boolean OK = true;
        
        for (Enumeration e = scheduled.keys(); OK && e.hasMoreElements(); ) {
            Machinetta.State.BeliefType.ProxyID proxy = (Machinetta.State.BeliefType.ProxyID)e.nextElement();
            Integer i = (Integer)scheduled.get(proxy);
            
            // Machinetta.Debugger.debug( 1,"Schedule check for " + i + " and " + scheduleTime);
            if (i.intValue() < scheduleTime) {
                OK = false;
            }
        }
        
        // Notice we are sending to all WASMS even if they don't need to change the
        // schedule just to ensure that correct proposed path is in latest weapon state
        if (scheduleTime != lastRequestedTime) {
            lastRequestedTime = scheduleTime;
            for (Enumeration e = scheduled.keys(); e.hasMoreElements(); ) {
                Machinetta.State.BeliefType.ProxyID proxy = (Machinetta.State.BeliefType.ProxyID)e.nextElement();
                if (!outstandingScheduleRequests.containsKey(proxy)) {
                    BeliefID roleId = (BeliefID)rolePerforming.get(proxy);
                    JIAgent jia = new JIAgent(plan.getID(), roleId, JIAgent.JI_STATE.SCHEDULING_REQUEST);
                    jia.setScheduleTime(scheduleTime);
                    jia.uniqueID = uniqueID;
                    MACoordination.moveAgent(jia,  proxy);
                    Machinetta.Debugger.debug( 1,"Schedule Created and sent a jia to " + proxy);
                    
                    // @todo Problem here if deallocated, because request is not removed
                    outstandingScheduleRequests.put(proxy, null);
                } else {
                    Machinetta.Debugger.debug( 0,"Not resending schedule change request to " + proxy);
                }
            }
        }
        return OK;
    }
    
    public Machinetta.State.BeliefType.Belief getAgentAsBelief() {
        return new Machinetta.State.BeliefType.MAC.PlanAgentBelief(this);
    }
    
    public Machinetta.State.BeliefID[] getDefiningBeliefs() {
        Machinetta.State.BeliefID[] bids = new Machinetta.State.BeliefID[1];
        bids[0] = plan.getID();
        return bids;
    }
    
    public void _merge(Agent a) {
        // Since plan agents can't move yet, this can't really happen
        // Work out what to do when I work out when they move.
        Machinetta.Debugger.debug( 2,"_merge called in PlanAgent, but nothing done .... ");
    }
    
    /** Checks to see if the plan should be terminated. */
    @SuppressWarnings("unchecked")
    public void stateChanged() {
        if (terminated) return;
        
        java.util.Hashtable matches = plan.matchPostconditions(PlanAgentFactory.getTriggers());
        if (matches != null) {
            // We match the post-conditions of this plan, so deactivate plan
            Machinetta.Debugger.debug(2,"Postconditions match for "+plan+" : " + matches);
            // since the plan is terminating due to completion, set the conflict number low so that no duplicate plans
            //  can be created
            conflictNo = Double.NEGATIVE_INFINITY;
            terminate();
        }
        
        if (waitingForGeneratedInfo.size() > 0) {
            LinkedList<RoleBelief> initiated = null;
            synchronized(waitingForGeneratedInfo) {
                
                for (RoleBelief role: waitingForGeneratedInfo) {
                    Machinetta.Debugger.debug( 0,"Checking whether " + role + " now has the information it needs ... ");
                    LinkedList<GeneratedInformationRequirement> toRemove = null;
                    for (GeneratedInformationRequirement gir: role.generatedInfo) {
                        if (gir.proscribed != null) {
                            Belief b = state.getBelief(gir.proscribed);
                            if (b != null) {
                                Machinetta.Debugger.debug( 1,"Found GIR !!! " + b);
                                if (toRemove == null) toRemove = new LinkedList<GeneratedInformationRequirement>();
                                toRemove.add(gir);
                                try {
                                    Hashtable<String,Object> hash = (Hashtable<String,Object>)(role.getParams());
                                    hash.put(gir.name, b);
                                } catch (ClassCastException e) {
                                    Machinetta.Debugger.debug( 3,"Error: GeneratedInformationRequirement do not work if role params are not a hashtable");
                                }
                            }
                        } else {
                            Machinetta.Debugger.debug( 5,"Unimplemented version of GeneratedInformationRequirement: No proscribed id" );
                        }
                    }
                    if (toRemove != null) {
                        role.generatedInfo.removeAll(toRemove);
                        if (role.generatedInfo.size() == 0) {
                            Machinetta.Debugger.debug( 1,role + " now has all information required to start");
                            if (initiated == null) initiated = new LinkedList<RoleBelief>();
                            initiated.add(role);
                            RoleAgent ra = new RoleAgent(role, uniqueID);
                        } else {
                            Machinetta.Debugger.debug( 1,role + " received some GIR, but still requires more: " + role.generatedInfo);
                        }
                    }
                }
            }
            if (initiated != null) {
                synchronized(waitingForGeneratedInfo) {
                    waitingForGeneratedInfo.removeAll(initiated);
                    
                    Machinetta.Debugger.debug( 1,"After agent started with all info: " + waitingForGeneratedInfo + " " + initiated);
                }
            }
        }
        
        
        // Horrendously inefficient ... FIX
        allowStart();
    }
    
    /**
     * Terminate this plan agent, need to let role performing agents know. <br>
     *
     * Notice that the plan agent is not removed because there may be other role agents
     * out there that we haven't informed yet.  Need a better solution to this ... <br>
     *
     * This was made public so that meta-reasoning agents can terminate it.  Probably not a very
     * elegant solution. <br>
     */
    public void terminate() {
        terminated = true;
        Machinetta.Debugger.debug( 2,"Terminating plan " + this);
        if (rolePerforming.size() > 0) {
            // Need to inform any agents performing roles in this plan
            for (java.util.Enumeration li = rolePerforming.keys(); li.hasMoreElements(); ) {
                Machinetta.State.BeliefType.ProxyID dest = (Machinetta.State.BeliefType.ProxyID)li.nextElement();
                BeliefID roleID = (BeliefID)rolePerforming.get(dest);
                JIAgent jia = new JIAgent(plan.getID(), roleID, JIAgent.JI_STATE.PLAN_TERMINATED);
                jia.uniqueID = uniqueID;
                
                if (dest != null) {
                    MACoordination.moveAgent(jia, dest);
                } else {
                    Machinetta.Debugger.debug( 5,"Unknown destination for role terminate message!!!");
                }
            }
            started.clear();
            waitingForStart.clear();
        }
    }
    
    /**
     * Notice this is not currently used ...
     */
    private void move() {
        // Move?
        // Testing ... pick any proxy to go to
        if (!Machinetta.Coordination.MACoordination.moveAgentRandomly(this, false)) {
            Machinetta.Coordination.MACoordination.removeAgent(this);
        }
    }
    
    public String toString() { return "PlanAgent:" + plan.getID() + ", id: " + uniqueID; }
    
    public static final long serialVersionUID = 1L;
}
