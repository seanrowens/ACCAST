/*******************************************************************************
 * Copyright (C) 2017, Paul Scerri, Sean R Owens
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
/*
 * SimOperatorGUI.java
 *
 * Created on March 20, 2006, 9:44 AM
 */

package AirSim.Commander;

import AirSim.Environment.Vector3D;
import AirSim.Machinetta.Beliefs.Location;
import AirSim.Machinetta.Beliefs.AssetStateBelief;
import AirSim.Machinetta.Beliefs.UAVLocation;
import AirSim.Machinetta.Beliefs.UGSSensorReading;
import AirSim.Machinetta.Beliefs.VehicleBelief;
import Machinetta.State.BeliefType.ProxyID;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferedImage;
import java.util.Enumeration;
import java.util.Hashtable;
import java.util.Vector;
import javax.swing.JPanel;

/**
 * @deprecated
 *
 * @author  pscerri
 */
public class SimOperatorGUIOld extends javax.swing.JFrame {
    
    public LocDisplay locDisplay = new LocDisplay();
    
    /** Creates new form SimOperatorGUIOld */
    public SimOperatorGUIOld() {
        initComponents();
        
        locPanel.setLayout(new BorderLayout());
        locPanel.add(locDisplay, BorderLayout.CENTER);
        locPanel.revalidate();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        locPanel = new javax.swing.JPanel();
        jScrollPane1 = new javax.swing.JScrollPane();
        messagesTF = new javax.swing.JTextArea();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        locPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        org.jdesktop.layout.GroupLayout locPanelLayout = new org.jdesktop.layout.GroupLayout(locPanel);
        locPanel.setLayout(locPanelLayout);
        locPanelLayout.setHorizontalGroup(
            locPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 580, Short.MAX_VALUE)
        );
        locPanelLayout.setVerticalGroup(
            locPanelLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 484, Short.MAX_VALUE)
        );

        messagesTF.setColumns(20);
        messagesTF.setRows(5);
        jScrollPane1.setViewportView(messagesTF);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, locPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 582, Short.MAX_VALUE))
                .add(233, 233, 233))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .add(locPanel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 184, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        pack();
    }// </editor-fold>//GEN-END:initComponents
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new SimOperatorGUIOld().setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JPanel locPanel;
    public javax.swing.JTextArea messagesTF;
    // End of variables declaration//GEN-END:variables
    
    public class LocDisplay extends JPanel {
        
        private Hashtable<ProxyID,UAVLocation> locs = new Hashtable<ProxyID,UAVLocation>();
        private Hashtable<ProxyID,AssetStateBelief> groundLocs = new Hashtable<ProxyID,AssetStateBelief>();
        private Vector<UGSSensorReading> ugssrs = new Vector<UGSSensorReading>();
        private Vector<VehicleBelief> vbs = new Vector<VehicleBelief>();
        private Vector<BufferedImage> images = new Vector<BufferedImage>();
        private Vector<Vector3D> imageLocations = new Vector<Vector3D>();
        
        private Color UGSColor = new Color(0.0f, 1.0f, 0.0f, 0.3f);
        private Color OPColor = new Color(1.0f, 0.0f, 0.0f);
        
        public LocDisplay() {
        }
        
        public void paint(Graphics g) {
            Graphics2D g2 = (Graphics2D)g;
            
            g2.clearRect(0, 0, (int)getSize().getWidth(), (int)getSize().getHeight());
            
            double dx = getSize().getWidth()/50000.0;
            double dy = getSize().getHeight()/50000.0;
            
            for (Enumeration<UAVLocation> e = locs.elements(); e.hasMoreElements(); ) {
                UAVLocation loc = e.nextElement();
                g2.drawOval((int)(loc.latitude*dx), (int)(getSize().getHeight() - loc.longtitude*dy), 10, 10);
                g2.drawString("" +loc.id, (int)(loc.latitude*dx), (int)(getSize().getHeight() - loc.longtitude*dy));
            }
            
            for (Enumeration<AssetStateBelief> e = groundLocs.elements(); e.hasMoreElements(); ) {
                AssetStateBelief loc = e.nextElement();
                g2.drawRect((int)(loc.xMeters*dx), (int)(getSize().getHeight() - loc.yMeters*dy), 10, 10);
                g2.drawString("" +loc.pid, (int)(loc.xMeters*dx), (int)(getSize().getHeight() - loc.yMeters*dy));
            }
            
            g2.setColor(UGSColor);
            synchronized(ugssrs) {
                for (UGSSensorReading s: ugssrs) {
                    g2.fillOval((int)(s.getX()*dx), (int)(getSize().getHeight() - s.getY()*dy), 30, 30);
                }
            }
            
            g2.setColor(OPColor);
            synchronized(vbs) {
                for (VehicleBelief b: vbs) {
                    g2.drawRect((int)(b.getX()*dx), (int)(getSize().getHeight() - b.getY()*dy), 30, 30);
                    g2.drawString(b.getConfidence()+":"+b.getType(), (int)(b.getX()*dx), (int)(getSize().getHeight() - b.getY()*dy));
                }
            }
            
            synchronized(images) {
                for (int i = 0; i < images.size(); i++) {
                    BufferedImage img = images.get(i);
                    Vector3D loc = imageLocations.get(i);
                    Machinetta.Debugger.debug("Drawing image @ " + (int)(loc.x * dx) + " " + (int)(loc.x * dx), 1, this);
                    g2.drawImage(img, null, (int)(loc.x * dx), (int)(loc.y * dy));
                }
            }
            
        }
        
        public void addUAVLoc(UAVLocation loc) {
            UAVLocation oldLoc = null;
            if (locs.containsKey(loc.id)) {
                oldLoc = locs.remove(loc.id);
            }
            if (oldLoc != null && oldLoc.getTime() > loc.getTime()) {
                locs.put(oldLoc.id, oldLoc);
            } else {
                locs.put(loc.id, loc);
            }
            repaint();
        }
        
        public void addUGSSensorReading(UGSSensorReading r) {
            synchronized(ugssrs) {
                ugssrs.add(0, r);
                if (ugssrs.size() > 50) ugssrs.remove(ugssrs.size() - 1);
            }
            repaint();
        }
        
        public void addVehicleID(VehicleBelief b) {
            synchronized(vbs) {
                vbs.add(0,b);
                if (vbs.size() > 50) vbs.remove(vbs.size() - 1);
            }
            repaint();
        }
        
        public void addGroundLoc(AssetStateBelief loc) {
            AssetStateBelief oldLoc = null;
            if (groundLocs.containsKey(loc.pid)) {
                oldLoc = groundLocs.remove(loc.pid);
            }
            if (oldLoc != null && oldLoc.time > loc.time) {
                groundLocs.put(oldLoc.pid, oldLoc);
            } else {
                groundLocs.put(loc.pid, loc);
            }
            repaint();
        }
        
        public void addImage(Vector3D loc, BufferedImage img) {
            Machinetta.Debugger.debug("Adding image .... ", 1, this);
            synchronized(images) {
                images.add(img);
                imageLocations.add(loc);
                while (images.size() > 10) {
                    images.removeElementAt(0);
                    imageLocations.removeElementAt(0);
                }
            }
            repaint();
        }
    }
}
