/*******************************************************************************
 * Copyright (C) 2017, Paul Scerri, Sean R Owens
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 
 * 3. Neither the name of the copyright holder nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 ******************************************************************************/
/*
 * ProbDistDisplay.java
 *
 * Created on February 1, 2006, 11:14 PM
 */

package AirSim.Machinetta.CostMaps;

import AirSim.Environment.Assets.Sensors.EmitterModel;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Dimension;
import java.awt.Graphics;
import java.awt.Graphics2D;
import javax.swing.JPanel;
import java.awt.Point;

/**
 *
 * @author  pscerri
 */
public class ProbDistDisplay extends javax.swing.JFrame {
    
    public int [] testlines = new int[8];
    private EmitterModel [] targets = null;
    public boolean drawLines = false;
    private double mapScale=0.0;
    
    /** Creates new form ProbDistDisplay */
    public ProbDistDisplay(double mapScale) {
        super("NEW BBFFinal ProbDist");
        this.mapScale = mapScale;
        initComponents();
        
        setSize(new Dimension(500, 500));
        mainP.setLayout(new BorderLayout());
        mainP.add(dist, BorderLayout.CENTER);
        for(int i=0; i<testlines.length; i++){
            testlines[i] = 0;
        }
    }
    
    public ProbDistDisplay(double mapScale, EmitterModel [] targets) {
        this(mapScale);
        this.targets = targets;
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        mainP = new javax.swing.JPanel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        org.jdesktop.layout.GroupLayout mainPLayout = new org.jdesktop.layout.GroupLayout(mainP);
        mainP.setLayout(mainPLayout);
        mainPLayout.setHorizontalGroup(
            mainPLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 360, Short.MAX_VALUE)
        );
        mainPLayout.setVerticalGroup(
            mainPLayout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(0, 304, Short.MAX_VALUE)
        );

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.LEADING, layout.createSequentialGroup()
                .addContainerGap()
                .add(mainP, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(64, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.LEADING, layout.createSequentialGroup()
                .addContainerGap()
                .add(mainP, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(50, Short.MAX_VALUE))
        );
        pack();
    }// </editor-fold>//GEN-END:initComponents

    public void setData(double [][] d) {
        currData = d;
//         dist.repaint();
    }

    public void testLines(){
        dist.repaint();
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel mainP;
    // End of variables declaration//GEN-END:variables
    private Dist dist = new Dist();
    
    double [][] currData = null;
    
    class Dist extends JPanel {
        public void paint(Graphics g) {
            
           
	    long startTime = System.currentTimeMillis();
            Graphics2D g2 = (Graphics2D)g;
            
            
            if (currData != null) {                
                double w = getSize().width;
                double h = getSize().height;
                double dx = w/((double)currData.length);
                double dy = h/((double)currData.length);
             
                g2.clearRect(0, 0, (int)w, (int)h);
                for (int i = 0; i < currData.length; i++) {
                    for (int j = 0; j < currData[i].length; j++) {
                        g2.setColor(new Color((float)Math.max(0.0, 1.0 - 50.0*currData[i][j]), (float)(Math.min(1.0, 50.0*currData[i][j])), 0.0f));
                        if(currData[i][j] < 0.0001) g2.setColor(Color.white);
			if(currData[i][j] > .99)
			    g2.setColor(Color.yellow);
			else if(currData[i][j] > .98)
			    g2.setColor(Color.cyan);
                        else if(currData[i][j] > .9) 
			    g2.setColor(Color.magenta);

                        g2.fillRect((int)Math.floor(i*dx), (int)Math.floor(j*dy), (int)Math.ceil(dx), (int)Math.ceil(dy));
                    }
                }
                
                 if (targets != null) {                    
                    g2.setColor(Color.black);
                    for (int i = 0; i < targets.length; i++) {
                        g2.drawOval((int)(dx*(targets[i].x/mapScale)), (int)(dy*(targets[i].y/mapScale)), 10, 10);
                    }
                }
            }
	    long endTime = System.currentTimeMillis();
	    long totalTime = endTime - startTime;
	    Machinetta.Debugger.debug("paint: total="+totalTime,1,this);
	    
        }

        public java.awt.Dimension getPreferredSize() { return new Dimension(400,400); }
                
    }
}
